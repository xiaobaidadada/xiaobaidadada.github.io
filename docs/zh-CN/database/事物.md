

数据库，每一步都会进行持久化操作，数据库的结构，一般来说都会用树保存，为了减少磁盘的查询次数，这些持久化的操作并不会直接保存到这个树的数据结构上，一个是因为这样很消耗性能，如果可以把多个更新操作同时进行可以减少磁盘的写入，另一个就是为了实现事物，在mysql中这也叫做mvcc机制，对于很多数据库而言，事物的机制都会很类似的。



事物的实现一般不会用锁，而是日志，是为了允许一些可能存在的同步行为，说是为了提高并发性其实也是不合适的，因为同一个动作并不允许并发。



事物有两个类型的隔离级别：

这个指的是两个或者多个事物隔离的程度，这里所说的概念，适用于大多关系数据库

1. 写级别，一个事物修改，另一个事物就无法，一般只针对于同一行数据锁定
2. 读级别，一般有读未提交，读已提交，可重复读，序列化（有顺序的执行-读）

# 日志

数据库的更新操作一般会记录日志，这种日志并不像我们自己写业务代码的日志，格式乱七八糟的，这种日志每一行都有特定的格式，和特定的数据结构。



数据库中每个记录都会有一个更新指针指向这个日志，在**mysql中叫做undo文件**，在sqlite中称为wali结构，其它数据中都有类似的，用于保存更新操作的日志文件（插入，更新，删除）。对于同一行记录，在事物中执行更新后会先生成日志记录，前一个日志指向后一个日志，形成一个版本链，且每个日志上都标记着自己属于哪个事物(**每次更新都是一个独立的事物id**）。（在mysql中还会存在着一个**redo日志文件保存sql语句**，配合这个版本链执行每一行更新）。



这样对于同一行记录产生了事物id，别的事物要执行更新，就要等待提交。



另一个读隔离级别的实现，依靠的是事物id的递增性，是的，事物id普遍是递增的，读隔离级别，通过读的时候生成的事物id和查询到的记录的事物的id（没有更新，就没事物id）进行大小比较，从而判断能不能读，或者能到版本连中的哪个节点的数据。**所以对于一个事物而言，并不会产生事物id，只有进行读取或者更新的时候会产生事物id。**



读未提交是，读的时候不生成事物id，不做判断直接读最后一个节点的数据。读已提交指的是，读的时候判断该记录是否有事物id，看看是不是已经提交的事物记录。可重读读指的是，每次读生成一个事物id，不管是有没有提交记录，他要求的是能够读到当前状态之前的所有数据，包括没有提交的，就是通过事物id大小进行读取的。序列化一般使用锁。



以上，所有的事物操作，都是通过递增的事物id，版本链，通过判断事物id大小来达到目的。我们自己如果设计持久化的软件，也可以参考这样的操作。不过这是用于并发的，没有并发读的需求，没有必要使用版本链。



# spring中的事物



在java中的spirng框架，transaction 注解，是一个非常好用的事物管理方式，它利用aop，通过判断数据源类型，提供了各种类型的数据库的事物的统一办法。还提供了多个方法调用之间的管理传播机制，一个事物能不能影响另一个事物，如果我们是通过写sql，一次是只能进行一个事物的，在业务代码中，事物变成了函数，函数之前的调用，发生了事物之间的交互，transaction 提供了这种交互之间的处理机制。







