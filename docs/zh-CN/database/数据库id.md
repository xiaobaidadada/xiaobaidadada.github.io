# id的类型

从id关系上分就两种：

1. id直接是顺序增长关系
2. id直接是无序关系

## 顺序增长型的id

这类id就是自增id，或者用雪花算法生成的id，不管是哪种，对于关系型数据库，有索引的存在，想要提高查询效率，主键索引就必须要是自增的；

这种会面临分库分表，在不同主机上也要保存顺序的问题。

# 无序id

典型就是uuid，这种id数据之间无数据关系，对关系型数据库是不友好的，或者说，对所有利用到索引的数据库都是不友好的，在es或者mongo中有索引的字段也不能是这样的，不管什么方式的uuid，都有再同一时刻出现相同id值的情景，虽然概率很小；

# 用哪个好

数据量很小，用啥都无所谓；数据量大，就必须用自增的，在关系数据库中可以保证插入删除，和查询的速度；所以，数据量大，数据库用到了索引，就必须用这个（关系数据库一般都有个聚集索引存在）

在什么时候用无序类型的呢，对外提供的数据id，如果考虑到安全问题，不能暴力自增 id，否则别人会知道数据的规模，更有甚者，可能通过自增id去获取别的不在自身权限之内的数据；再比如数据需要迁移，id之间的关系由于自增有会冲突，会发生变化，这也是不友好的，此时也可以用这个；总的来说，只要是有特殊的不同数据之间的关联需求，就需要这个；（安全也是数据之间有关系导致的泄露规模和顺序访问权限问题）



# 在顺序增长型的id中的生成方式

这里根据生成实体也可以分为两种：

1. 数据库本身
2. 代码实现

数据库本身，肯定有这个功能，代码实现的方式有很多了，这就是一种技术，免费开源的有雪花算法，可以保证多个平台的数据库上的id自增，但是有重复的概率（很小），因为这种顺序关系不是依靠上一个记录产生的，而是通过时间戳（别的数据只是保证不重复），虽然一秒可以产生几十万的id，但是这个方式依然是依靠时间，且是个常量值，如果有每秒几十万的人同时插入数据的需求，服务器也能受的住，那么就是有可能重复的；虽然概率很小；

目前类似雪花算法的方式，很多公司可能有自己设计的，如果可以利用一个分布式的主键生成器服务器，那么就彻底拜托了可能会重复的问题，也保证了在多个数据库上的唯一性问题，但是目前世界上的项目应该没有几个有必要这么做的；

