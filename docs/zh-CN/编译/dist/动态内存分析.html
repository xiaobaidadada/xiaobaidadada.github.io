<h1>nodejs内存泄露问题发生的根本原因</h1>
<p>1： <a href="/zh-CN/java/jvm%E6%B5%85%E6%9E%90" onclick="handleLinkClick(event)">jvm</a> 这篇文章是关于java虚拟机的垃圾回收机制的讲解，nodejs的垃圾回收机制和jvm的很相似，原理相同。</p>
<p>2:：当对象保持着引用关系，内存就会持续增长</p>
<p>3：当面临大量数据运算的时候，新生代空间短期内会不够用，导致崩溃。v8只提供老年代的空间限制，新生代并不能设置。</p>
<p>可能发生的情况</p>
<ol>
<li>
<p>使用了全局变量集合，但是没有做清理，临时无用的临时数据一直被全局变量引用着。但是使用全局变量对于大量数据运算的时候，是可以重复利用的，这样反而可以减少gc次数，提供性能，但是要小心使用。</p>
</li>
<li>
<p>使用了闭包，闭包在编程语言中指的是，函数运算的时候，函数将外部变量的作用域引入到了自身内部。这个外部变量不管是不是全局变量，对于这个函数来说就是全局的，一直不会消失，闭包的意思是函数的定义包括了外部变量。</p>
</li>
</ol>
<h1>代码上出现的场景可能有：</h1>
<ol>
<li>
<p>在类中定义了一个函数，这个函数使用了类的变量，这种情况的闭包是很合理的，一般不会出现内存泄露。</p>
</li>
<li>
<p>在一个函数中，定义了一个函数，或者定义了一个类，在js中类和函数本质上是同一个东西，这个类或者变量使用了函数的变量，这些变量将被闭包成为不会消失的变量，由于这个函数本身就是临时的，所以这种情况很容易出现内存泄露。指的注意的是，创建对象引用并不会出现这个问题，这个问题只对类和对象，属于类型定义。像{}这样只是直接创建，不属于定义类型。</p>
</li>
<li>
<p>promise使用，这个本质上也是2的说明，在使用这个特性的时候，必须要使用闭包，因为他不支持传递参数，这很容易出现内存泄露的闭包。所以如果要使用promise，所使用的变量必须是全局的，而不是局部的。</p>
</li>
<li>
<p>使用了外部组件库，外部组件对象会渲染到一个div上，此时，就算div消失，这个组件对象也不会消失，因为div的这种获取一旦获取成功，一般不会再次获取，不会报错，如果返回创建多个组件对象，只是对同一个div做了多次覆盖操作。</p>
</li>
<li>
<p>对于vue而言，vue的组件有着自动挂载销毁的功能，比如v-if 如果从true变成false组件就销毁了，但是组件内存的dom对象，以及该对象上绑定的数据可能并没有销毁。</p>
</li>
</ol>
<h1>如何定内存泄露</h1>
<ol>
<li>
<p>先判断是不是内存泄露，通过观察，查看是不是当不再运算以后内存会降到符合预期的大小，如果是，那么只是因为计算量太大，临时对象太多。</p>
</li>
<li>
<p>如果内存一直保持着增长，让程序内存增长一下，然后通过浏览器，或者使用heapdump，打印一下内存快照。</p>
</li>
<li>
<p>使用内存快照查看工具，浏览器开发者工具，或者devtools等，查看内存快照中存在的对象之间的关系。这个以后可以出个详细的文章教程，(通过构造函数视图)，找到对象对多的构造函数，然后查看该对象在哪个对象中引用着...)</p>
</li>
<li>
<p>预期上，发生了内存持续增长，应该不存在任何没有被引用的变量，变量都是有引用关系的，此时应该查看什么对象最多，定位对象的引用位置。</p>
</li>
<li>
<p>如果定位到了对象是我们自己定义的类型，这是最好的结果，如果对象只是一些数组和字符串，这个 时候要定位要这些对象被谁引用着，尽量往上追到一个特殊的对象，我们的目的是发现能够标识出代码问题的对象，通过特殊的对象，找到这个对象在代码的位置，分析这些位置出的代码逻辑，检查是否有闭包问题，或者别的问题导致引用一直保持。</p>
</li>
<li>
<p>这种分析办法适用于任何动态内存语言，Java python也适合</p>
</li>
</ol>
<h1>闭包造成的内存泄漏</h1>
<p>闭包是最有可能造成内存泄漏的问题。其实闭包本身没有什么问题，下面这段代码</p>

      <div class="code-block-with-copy">
        <button class="copy-btn" data-code="function kk() {
     let i = 0;
     return function() {
         return i;
     }
 }
console.log(kk()())" >复制</button>
        <pre><code>function kk() {
     let i = 0;
     return function() {
         return i;
     }
 }
console.log(kk()())</code></pre>
      </div><p>这样一个内部函数引用了外部函数的变量（也可能可以是前面说的别的情况造成的闭包），其实是不会有内存泄漏的，因为这个内部函数执行完了，函数也没有被引用，只是一次性的执行。</p>
<p>当内部函数作为变量被返回，且一直被引用着，那么这个函数所引用的变量，将不会消失，特别是对于一些，函数中直接使用全局变量，全局对象的情况，如果让变量与这个全局对象引用着，这个肯定就会一直闭包了。</p>
<p>闭包形成的机制是这样的。</p>
<p>每一个变量，和对象都是没有关系的，将一个变量初始化的时候赋值一个对象，对象本身和这个变量是没有一点关系的，我们将这个变量不断的转移赋值给别的变量，将变量赋值为Null并不会改变对象的值，对象依然存在着，只有当所有的变量都不再引用这个对象了，这个对象才会被回收销毁。</p>
<p>发生闭包的时候，在内部函数，那么此时闭包指的就是，一<strong>个变量作用域，这个作用域普遍是一个函数作用域，作用域内会创建一个名字和函数外部一样的变量，外部的变量其实是被复制了一份</strong>。在这个闭包域内也有一个相同的变量。</p>
<p>我们在闭包区域外部将变量赋值为null，这在闭包内部其实并不会有用。所以我们要在闭包的外部和内部都保证变量可以被失去引用。可能出现<strong>问题</strong>的闭包域有这些：</p>
<ol>
<li>每次调用函数，将对象传递给函数的<strong>参数</strong>，此时该参数在这个函数内部就是一个闭包域。</li>
<li>在函数内部调用了全局或者局部的外部对象，该变量会被复制一份到这个闭包域。</li>
<li>在函数内部调用了另一个函数，该函数已经使用了闭包域外的变量，又传递给了这个函数，此时该变量将会又被复制一份。成为被调用的另一个函数的闭包域的一部分。</li>
</ol>
