# node基本

node.js 是一个js运行vm，但是我们知道，jvm肯定包含了很多的组成部分的，jvm的虚拟机大部分都是hotsopt，node.js 的虚拟机就是v8, v8和hotsopt的主要开发人员其实一样😂。

所以，在v8中，java虚拟机的概念也都可以看到，不过java虚拟机中的理论都是经过多年迭代过后的结果，不仅仅在java虚拟机中有应用，在go等各类语言中也有应用。

v8和hotspot最大的区别是，js虚拟机是解释执行的，而java虚拟机是将整个类直接加载到内存中，所以js的性能要绍弱于ava虚拟机的。v8 也采用了堆来管理所有的对象，也有新生代和老年代的划分，这些堆的大小也可以指定。默认是当堆内存超过80%后就会触发GC。但是v8默认的堆内存并不是很大，是因为v8被设计的目的一开始是用于浏览器的。

node 被发明出来的目的是要做一个非堵塞的系统，所有的i/o都是异步的。对于操作系统而言，只有堵塞和非堵塞，异步是要程序自己实现的，v8的用户线程是单线程，但是运行的时候是多线程的，其他线程用于实现异步，不断的轮询i/o请求的结果。

虽然node的用户代码是单线程的，但是可以通过创建类似浏览器的子进程来达到多线程的目的，但是这个一般只作为池化管理，并不会让一个请求单独生成一个线程，这太消耗性能了。

v8和hotsopt都并没有提供系统函数，类似tcp这样的工具，这些实现都是依靠扩展c++二进制代码库，直接调用的，vm只是一个解释代码的引擎。在v8中这个机制叫做C++ Addons，Java中叫做JNI，正式由于这样的机制，才有了丰富的库函数支持。

# npm包管理器

python中有php，java中有maven，nodejs有Npm.

这个npm设计的太过于着急了，js这门语言本身就是一个设计过于着急，许多地方都不完善，而npm也....。

用过java 开发的都知道，maven 中，电脑上有一个本地仓库.m2文件，所有的库都在这里，每个项目里面不会有实际的包。

但是npm会在每个项目下面都建立一个node_modules。最开始的时候是包依赖有多少，就嵌套的下载多少包，由于后端代码复用非常常见，导致这个node_mdules有很深的文件层，而且很多包都是重复的。然后npm将所有的包铺平了，都在同一层。其实yarn是第一个这样做的，npm后来模仿yarn实现了一遍。

但是这样依然...每个项目都要把依赖下载到项目中，很多个项目其实包还是重复的，所以又有了pnpm，pnpm将node_modules中的每个文件夹和文件，都采用文件系统的引用，也就是widnwos快捷方式的作用，电脑上只有一个包仓库，所有的项目的node_modules都是引用这里的包。所以这样是最能节省磁盘的。

但是这样还是要生成node_mudules，为什么一定要这样的呢，我猜测是因为，许多框架已经使用了这样的npm的node_modules结构，如果突然改变，到导致许多框架不能使用了，这样对node的生态会有影响，相信未来npm应该有办法可以做到这一步。