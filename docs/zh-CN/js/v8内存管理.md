# 内存区域

内存区域中区域指的是，存放对象的集合，内存管理其实就是对象管理，只有对象需要被管理，在c++和c中需要手动释放的内存也就是对象和直接内存。

存放对象的区域每个动态语言都会有这三个，新生区域，老年区域，永久区域。每个区域又可能会进一步划分一些小区域，不过总的来说都是保存对象的集合。这些集合肯定是使用c++进行连续的申请的内存空间。每个区域的垃圾清理方式都不同。

在nodejs中，buffer对象虽然不属于v8管理，但是nodejs还是需要判断是否有对象引用着这个对象，只是清除的方式不同了。

# 动态内存语言

python, java , go , js 都是动态内存语言，动态内存语言指的是不能手动申请内存，创建的对象也不需要自己手动删除内存，在c++中创建的对象自己不释放就会一直存在着，很容易发生内存泄漏。

动态内存语言，底层都是c++对象，c++提供执行这些语言的环境，主动判断这些对象是否没有被使用了，然后自动清除这些对象。

对于常量，非对象的类型的变量，在作用域消失后他们也会消失，并不需要被管理。

# 怎么动态管理对象

下面的这些处理方法，其实对于任何一个动态语言，解决方式都是类似的，动态语言的内存管理，最先进的应该是java，java的内存管理的变化就是动态内存管理的一个缩影。v8的内存管理也可以在java的一些内存管理器看到，况且开发v8虚拟机的人和开发jvm的都是同一批。

## 首先，将对象放到合适的内存位置

刚创建的对象会进入到新生代区域中。如果对象在一次GC（进行垃圾回收操作）后没有被清除掉，经过几轮后，就会被转移到老年代区域。

## 怎么判断对象是否不会再被使用了

只有两种常用的方式，引用计数和可达性分析，引用计数对于自己开发的c++项目框架可能是很有用的，对象的关系可以保证，但是对于编程语言的应用，对象的关系不能保证，可能会出现互相引用的情况，所以动态语言都是用可达性分析来判断是否还会被使用。

从一些顶级对象（不会被回收）判断其它的对象有没有被应用的，没有被任何引用的对象，又不是顶级对象，就会被判定不会在被使用了。

## 不在被使用的对象怎么清除

对于不同的内存区域，方式也会不同。清除一定是先进行的判断，或者已经很长时间没有gc了才会进行，一般新生代的频率比较快，老年代比较慢，老年代空间不够了，新生代又有新的对象引入就gc。

### 新生代

使用的是将对象再分别放到两个区域，from和to，对两个区的对象分别判断，然后把一个区的还被引用的对象都放到另一个区。这种角色交换办法，就是标记复制，每次只用一半内存，另一份内存是空的。浪费内存，适合经常变化的对象，可能会出现很多不连续对象的情况。

### 老年代

有标记清除（有内存碎片问题），

标记整理，对标记清除的优化，整理空间很花cpu，但是省内存，适合不经常变化的内存空间。

