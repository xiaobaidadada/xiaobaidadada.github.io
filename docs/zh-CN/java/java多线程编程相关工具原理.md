# java多线程需要注意三点

1. 可见性：对象变量是当前线层从堆中深拷贝过来的，堆中的变量可能已经改变了，这个值可能不是最新的。
2. 有序性：多个指令（一个指令也就是一个以";"结尾的语句）jvm执行的时候为了提交运行效率可能会将这多个指令重新排序。
3. 原子性：一个操作比如 ++ 这样的指令不是一个操作，而是多个操作，多个操作的集合一起进行就是原子性。

这三点其实只有在java语言下才需要注意，别的语言不一定需要注意这三点，这三点完全是由于jvm的执行结构造成的。大量的多线程编程所需要的一种资源通常都是对象，而不是集合，资源的数量只有一个，符合锁的资源特征使用情况，所以锁被用的最多。

## 其他特点

由于java语言的特性，还需要知道这些特性

1. 线程函数的可重入性：一个线程的函数，多次执行，会多次获取锁，这个要看锁支持不支持可重入性了。但是对于别的语言，要看线程模型是什么了，可能不会存在这个情况。

# synchronized关键字

这个多线程工具是java语言特性提供的，他表示对类加锁，或者对类的实例对象加锁。同时也定义的临界区代码。

这个关键字只能加在三个地方，普通方法，静态方法，代码块上（需要加个对象）；这个保证了临界区的定义。

类有个class对象，对这个对象加锁，只要是静态的方法，不管多个线程调用哪个他们都争抢的是类。普通方法，都加这个关键字，不管多个线程调用的是多少个方法，争抢的都是对象实例，包括代码块的。



虽然这是个同步关键字，但是它的主要作用是为对象资源加锁，而不是信号量。保证多个线程只有一个对象可以访问这个对象资源进行方法的执行。

## synchronize原理

一个java对象在内存中有自己的结构，不用去搜也能想到的，哪个语言的对象实现都是这样，他的格式也是有头部和body组成。

当加了synchronize的代码，java在编译的时候会对synchronize修饰的方法编译后的字节码处加上获取锁，解锁的标识指令。每个对象结构其实都可能会关联一个**监视对**象，用于给对象提供一些额外的功能。这个监视对象包含java AQS中的特征，有一个临界区进入的次数count变量，有一个堵塞队列。一个线程加了锁的关键字，线程访问对象就需要访问对象的锁，可以多次，每一次count都会增加，只有所有的临界区方法都执行结束，每个结束count值都会减1，最后为0的时候，才会开启堵塞队列的其他线程获取机会。先入的现有机会获取锁。



synchronize生成的指令有这样的额外功能，所被加锁的对象，有不同的处理想要获取对象的办法，可以说成状态，且状态的改变不可逆转。**这些办法的目的就是尽量不进行锁的一般模型，入队列。。。。**，因为这些操作需要vm内核代码执行，用的代码执行变成内核代码执行，需要做很多的资源缓存标识操作，消耗时间。

- 第一种处理想要获取锁的线程的办法是，对线程进行标识，自己放弃了这个锁对象，下一次还是自己，直接拿，不需要判断队列是否为空，也不需要先入队列。
- 第二种处理，就是cas操作了，就是少数几个线程，不断的进行cas，判断是否是自己期待的值，cas循环的次数是有限制的，如果有一恶搞失败了，就会成为普通的对待线程的方式，先入队列。。。



实现其实也不复杂，不要想太多，记那么多高大上的名词。

synchronize的内部代码，具有原子性，有序性（对指令没有影响），所加锁的对象也具有volatile的可见性特性。

## synchronize与线程的使用

前面分析了，**每个对象**都有锁的结构与synchronize配合使用，所以wait( )，notify( )，notifyAll( )这些方法不是属于线程类的。而是属于每个对象的，使用这些函数，都是控制当前线程的对于这个对象的锁的队列同步控制。所以如果没有锁，多个线程无法让自己进入什么等待队列，因为就不存在这个队列，调用这个方法就会报错。线程可以控制自己睡眠不睡眠。

# volatile关键字

具有可见性，和有序性。不要记什么内存屏障，可见性就是jvm在对加了volatile的变量，在需要使用的时候会从堆中取最新的值，同时也该以后也会刷新到堆中。

他能禁止指令重排是值，加了volatile这个关键字的相关使用的指令，前部和后面的指令不能改变顺序，但前面和后面他们指令之间的顺序是可以变的。

那么如果没加volatile，变量的值什么时候会更新呢，这个可能是在一个计算时间片内的线程，只要执行完了任务，就会执行这个操作，或者一个代码块的代码执行完的时候也会更新。



# AQS抽象类工具

AQS指的是AbstractQueuedSynchronizer 类的简称，这个类是一个抽象类。在讲他的使用原理前先说个操作系统中的名词“**管程**”，管程指的是一个抽象数据类型，可以看作java中的一个对象。多个线程或者进程之间进行并发的执行，谁先执行，谁等待，是依靠依靠线程自己控制的，线程中自己写循环自己写判断。这种方式不利于软件开发的效率与维护性提升。所以用管程来替代线程自己与别的线程进行交互的行为。具体是这么做的，多个线程并行所操作的资源（信号量），管程的结构包含了这个信号量，还具有操作信号量的方法，不允许线程自己去操作信号量，线程的目的就是获取信号量对吧，那么现在只管调用管程就好了，管程会处理线程能否获取到资源，获取不到帮组线程挂起（加到等待队列），帮线程实现检测是否有资源的方法。管程的作用就是替代线程直接操作资源，替代线程自己控制自己的状态，检测资源等行为，线程只管实现处理资源的方法。

## AQS与管程的关系

AQS是管程的实现，资源信号量是锁，是对象。synchronize也是管程的实现，但是这个是jvm底层实现的，失去了线程显示控制方法的便利性。

## AQS类的组成

1. 有一个`private volatile int state`用于表达当前资源对象的状态，虽然只是一个int但并不一定只能表示一个资源，可以把int看做32位的32个二元资源。
2. 一个先入先出的线程队列（node节点内部类代表线程）。依靠head和tail两个属性指针控制队列的控制。但是会不会严格使用这个队列，要看实际使用，有些锁，会先进行cas尝试。
3. 一些模版方法，acquire（获取同步状态，获取资源，线程运行，否则入队列）；这样的获取资源运行函数，还有可以设置超时的。还有共享模式的。共享模式和独占模式的区别是，独占模式只考虑资源状态能不能拿到值，共享模式是资源数量是否大于0，多个线程一起并发的执行。release（释放同步状态，释放同步资源，释放完并唤醒线程队列）；这些模版方法都是final的，不允许修改。
4. 抽象方法，一共五个，tryAcquire，tryRelease，tryAcquireShared，tryReleaseShared，isHeldExclusively；这些五个方法，只用于获取state，也就是获取资源，释放资源的操作，资源具体是什么含义，用这些方法来指明，这些方法会被相应的独占式acquire。。。模版方法等调用。他们是一一对应的。因为AQS是一个工具，只负责线程的队列控制，堵塞等控制行为，对于资源的控制行为需要具体实现才行。
5. ConditionObject，一个Condition接口的实例，作用是用于独立提供一个FIFO线程队列，线程自己将自己await到这个队列，别的线程也可以单独对这个线程进行唤醒。当然这些线程这样就不一定会存在于AQS的队列中了。
6. 他有两种模式，其实就是两套acquire和release函数，前面也提了。

总的来说就是，AQS抽象类，内部有一个int资源对象，他自己提供获取锁和释放锁的函数给用户（使用这个类的程序）使用，然后获取锁和释放锁，具体是需要判断能不能获得资源对象，获取资源对象的方法需要用户来实现。其他的入队唤醒就交给aqs抽象类来处理了。

## AQS工具类的使用场景

AQS不会直接作为一个工具类用于业务代码中，而是当你想做一个线程同步工具的时候，可以在类的内部去实现使用这个AQS工具类。这是官方的建议，直接使用当然也是可以的，不过就是一次性的使用了。java中有很多的锁，都是利用这个AQS工具类作为基本工具来实现的，比如ReadWriteLock，ReentrantLock等。他们代表的资源都是对象，是锁的代表，如果有更复杂的资源，需要自己去做一些工具就可以利用AQS了；

## AQS工具类与Lock接口

Lock接口是锁资源的接口，java中基于lock的实现有很多，这些lock接口的实现类，大多都是利用AQS作为工具实现的。至于其他类型的资源，目前并没有接口和实现类。对于锁，下面这些锁，平时的业务开发是可能会利用到的。

lock接口包括了对象的wait等函数，而lock锁对象自己包含这一些操作。

java中对于lock接口的实现锁利用的工具类只有三个，ReentrantReadWriteLock（内部实现ReadLock，WriteLock，对外实现ReadWriteLock），ReentrantLock，StampedLock；均实现了超时获取锁，就是不断的判断时间戳进行cas呗。

所有的超时获取try方法，失败以后不会进入堵塞队列。

## ReentrantLock是如何利用AQS实现的

这个是lock接口的主要实现类。是一个功能标准的锁。和synchronize的功能几乎一样。它的lock接口实现，几乎是直接调用的AQS的函数，并没有别的指令，所以我们直接看它的特点，以及看它是如何实现AQS的五个抽象函数（就是trylock这些），从而提供这些特点。

他也是可重入的，就是指这个线程的函数可以执行多次。他并没有实现AQS的共享trylock等相关函数。

1. 公平与非公平：他有两个内部的公平和非公平sync类继承AQS，公平的trylock在已经被锁的时候会直接返回错误，AQS模版方法就会直接执行剩下的操作了，入队列，唤醒队列第一个线程...。非公平的trylock在已经被锁的时候会**进行一次cas尝试**，获取到了就直接执行否则才会入队列。**默认是非公平**。
2. 可重入性：state的值是可累计的，有一个exclusiveOwnerThread表示当前执行线程，不管是公平还是非公平，当state不为0的时候被锁的时候，trylock方法都会先判断竞争的线程是否是自己，是的话会累积state的值，最后release释放state为0；



## ReentrantReadWriteLock是如何利用AQS实现的

ReentrantReadWriteLock实现了ReadWriteLock接口，这个接口有返回两个lock接口实现类方法，虽然state只是一个int变量，这里ReentrantReadWriteLock将state按32位分为两部分（不同vm或者java版本可能大小不一样，但是肯定是偶数位，肯定可以分为两部分），分别表示两个state，使用&等按位计算操作控制，用于提供两个小值范围内的int state，分别用于表示读状态锁资源和写状态锁资源。这两个读写锁，不获取也会一直存在ReentrantReadWriteLock类中。

分析的方式和ReentrantLock的一样。这里有一个sync继承了AQS内部类，同时它的trylock等方法，成了模版方法，他提供了readerShouldBlock，writerShouldBlock两个抽象方法用于公平不公平的策略接口，选择公平不公平的sync实现类。两个lock的实现类，读写锁，这两个实现类都引用了sync内部类，所以虽然对外提供两个类，但是这俩类都是操作的同一个AQS内部类。

对于ReadLock实现内部类，它使用sync的共享资源接口，对于WriteLock实现内部类，它使用sync的独占共享资源接口。



1. 公平与非公平：这个也支持原理也是和前面ReentrantLock的一样，在获取不到资源的时候，会进行cas比较。这里需要它提供的抽象方法返回是不是公平的策略。对于state的所有操作都采用位移和位与方式；
2. 读锁能够拿到最大的锁资源是，65535，这取决于int的一半位数是16位。
3. 可重入性实现：对于读锁不存在这个问题，因为任意个线程都可以进入，不存在竞争堵塞。对于写锁，原理和上面的ReentrantLock一样。
4. 当有写锁的时候，读锁无法添加会失败进度堵塞。写锁进入的时候判断的是整个state，有写锁，有读锁都不行。将读锁变为写锁（称为锁降级，怎么会有这么sb的名字）需要自己手动先调用写锁释放，然后加读锁。



## StampedLock高性能读写锁

这个类并没有直接继承lock接口，也没有使用AQS。它提供了ReentrantReadWriteLock的基本方法，并没有报漏出单独的读和写锁用于外部控制；

他同样有一个FIFO队列，一个int的state；内部提供独立的读，写，读写三个视图lock接口可以用于独立获取控制这个锁。

他不是可重入的。

他有三种获取锁的方式，对应三种模式。读，写，乐观读。读，写，与ReentrantReadWriteLock提供的规则相同。但是这个乐观读，只要不处于写锁状态，都可以获取，而且乐观读锁，不会像读锁一样禁止别的线程获取写锁。

所有获取锁的方法都会返回一个long stamp，这不是时间戳，而是当前的state与模式表达的状态，这个值用于释放锁函数。但是乐观读锁方法获取的stamp没有必要释放.

有一个validate方法用于获取当前的stamp有没有被修改，线程自己的stamp能不能关闭锁。也支持超时获取，而不会进入队列，所有的try获取方法都不会进入堵塞队列。

# juc下其他的类

前面的锁是属于`java.util.concurrent.locks`下的工具，用于同步的工具除了锁，还有很多别的工具类在`java.util.concurrent.`可以使用。

1. atomic原子类，提供了操作原子对象的方法，他们提供的方法都是将多个方法合并为同一个方法，在执行期间内别的线程无法使用操作。
2. CompletableFuture，与future接口相比，这个返回之后可以提供then这样的方法作为异步处理。
3. ConcurrentHashMap：1.8 版本的java以前是采用分段的方式，让每个段加写锁。1.8以后使用和hashmap一样的实现方式，没有使用hashmap，而是方法和hashmap的一样，在put的时候，如果数组节点是null，会使用cas的办法尝试设置值，不需要锁。如果数组节点不是空的，会使用synchronized锁住数组节点进行扩容。hashTable是一个只采用数组，没有链表的关联数组容器，所有方法都加synchronize。
4. ConcurrentLinkedDeque不会堵塞，所有控制节点的操作都通过cas进行，无限次尝试进行。
5. ConcurrentSkipListMap 是一种顺序插入关联数组元素的线程安全map（插入遍历是同一个顺序），采用跳表实现，使用volatile关键字保证线程安全。对每个元素都加volatile；volatile会比cas和synchronized更花时间。
6. ConcurrentSkipListSet基于ConcurrentSkipListMap；
7. CopyOnWriteArrayList  读的时候没有锁，写的时候会加锁，并复制一个新的数组扩容副本。
8. CopyOnWriteArraySet 基于CopyOnWriteArrayList；
9. CountDownLatch：提供一个计算值和一个队列，当计数值为0的时候会唤醒所有队列上的线程。
10. ForkJoinTask 将多个任务分解为子线程，执行完加在一起，用于数字计算密集任务。
11. CyclicBarrier 多个线程都完成以后才会执行一个方法。
12. DelayQueue 延时队列，get元素可以延时获取。
13. Exchanger 两个线程交换数据，一个执行到使用Exchanger后，必须等另一个回应数据才能继续执行。
14. Phaser 不同阶段执行不同的线程。
15. Semaphore 信号量，提供安全的获取信号量的方法。如果资源为0，线程会一直堵塞。
16. TimeUnit 时间单位转换，定时或者延时线程接下来的行为。



# 什么时候会用到多线程

一般http业务开发，根本不会用到多线程，每一个请求都是单独在一个线程中，从http入口，然后查询数据库，再到返回都是独立的变量环境。但是还是有一些场景会遇到。

1. 事物，某些状态被占用。如果两个请求同时操作同一个数据，这个时候多个线程就有操作同一个数据的情况了，我们就需要采用一个全局的变量，再多个线程中去调用改变它的值，更多的情况是使用redis，redis的请求是单线程的，就可以保证了这个顺序，但是redis还需要注意，事物的完整性问题。
2. 对于一些信息统计问题，比如累计计算等信息。也是这个场景，如果两个请求的线程需要操作到同一个数据源就会出现这个问题。
3. 前面的这些问题，上面的这些多线程工具没有人会去用，都是redis，一定要用到这些多线程工具的是地方是各种底层框架，比如tomcat,spring，他们保证这些数据之间的关系，他们提供了多线程的使用环境，就需要面对多线程的数据关系。
