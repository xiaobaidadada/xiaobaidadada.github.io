# 什么是java nio

在看这篇文章之前，你要先知道基本的网络编程模型（可以看我的其它文章），想学netty一定要了解java NIO的基本操作才行，因为netty基本上是一个对java NIO的封装框架；



# JAVA nio

1. java nio是一个非堵塞框架，1.0版本依然是同步的，在最新的2.0版本后是真正的异步i/o模型。需要先明白java nio的编程模型，我不会用太多的代码去描述这些，我觉得，在学习一门技术之前，明白核心的概念是非常重要的，有人会说，要多做才行，实践出真理，我并不认为这是一个好的学习方式，明白核心概念以后再去学习，做一些例子能起到更好的效果；就像学英语，如果你不学语法，只靠背和读去学习，这是一个非常困难的事情，你需要花很多的时间去学习，一个英语环境下的孩子，五六岁就能学会一口流利的英语，你看他没有学习英语，其实它已经学了五六年，她的日常要做的每一件事都需要英语，别人也在说英语对他起到辅导作用，这是非常难得，如果学了语法我们就可以弯道超车几个月就可以理解英语的逻辑，不需要花几年去感受，也不需要天天学英语（当然学会学不会是另一回事）

2. 下面正式说一下java nio的概念

   ​	

   - Channel

     数据的载体，如同流，不过这个是双向可读可写的；

   - 回调

     就是一个函数，可以被框架由于事件的发生而自动调用；

   - Future

     异步操作结果，在javaapi中需要不断的访问检测是否完成，或者一直堵塞直到完成，neety的实现是ChannelFuture；提供回调函数当完成会主动调用函数，而不用在线程中主动访问了；

   - 事件和ChannelHandler

     不同的事件调用不同的handler，对于http等有现成的handler实现；

# 在netty中也存在着这些概念

netty是对java nio的封装，不明白java nio就无法使用netty；

我们可以通过一个 netty的实例，去看一下java nio和netty的对应关系

## 服务端

1. **先注册两个线程组**，一般普通编程，这两个线程组在java nio中是没有显示代码的，他们是java nio中的acceptor和client，对应着**selector**多路分发器的接收tcp请求处理的线程和接收完之后处理tcp数据的线程；

   参数可以只有一个，只有一个线程组的话这个线程组只能又当acceptor又当client；对于客户端只需要一个就行了；

   ```java
   EventLoopGroup bossGroup = new NioEventLoopGroup(1);
           // 创建 worker 线程组 用于进行 SocketChannel 的数据读写
           EventLoopGroup workerGroup = new NioEventLoopGroup();
   //可以对这俩线程组进行配置和设置；只能接受这个接口形式的线程组
   ```

2. **创建netty启动类并配置**

   - 配置线程组，.group函数
   - 配置通道类型，n**etty也需要通道**，他会自动创建统一的通道，只需要配置类型就好了，使用channel函数
   - 配置处理类（可以多个），在java nio中，程序员自己注册到多路选择器并设置事件类型；（其实还可以先绑定一个channel过滤器，然后从channel进行绑定配置处理类），这个类要继承一种netty预先提供的类，已经提供了一些处理，不同的函数就对应着不同的事件；
     - 事件函数的参数一个是channel，可以对他进行数据的发送，在这里没有缓冲buffer了，**函数的参数就提供了这些数据**
   - ...

   

3. 绑定本机的端口，执行堵塞函数进行监听

   

## 客户端

1. 前两步和服务器的一样
2. 不再启动监听服务，而是绑定ip和端口，

然后进行连接，连接完以后通过对channel的调用操作和服务器进行通信，并通过回调函数接收信息进行处理；

## 其它

- 发送数据需要使用channel更新函数

# 总结

总结一些netty和java nio中的概念的位置差别

1. selector多路选择器——》提供启动类，效果一样，并且可以设置acceptor和client线程组；使用reactor模式
2. 通道channel——》在netty中依然存在，不过不用自己创建对象了，只需要配置类型在启动类中
3. 缓冲区buffer——》不存在了，netty的回调函数handler参数为我们自动生成了，可以直接使用不用再获取；

  