# 什么是i/o模型

i/o  本质上指的是外部设备，在linux系统中，不管是文件，还是外设统统都用文件表达，在widows中，其实也是一样，虽然没有明确的规定，但是道理都差不多。

i/o模型，本质上指的是一个函数是如何处理i/o操纵的。所有的i/o都是由操作系统进行处理的，所有的操作系统内核都只能提供两种i/o处理方式，一直堵塞当前线程，直到处理完i/o，另一个是立即返回i/o文件（也可以是外设）文件会有是否完成的状态。

i/o模型函数在各种级别都存在着，所有的i/o模型函数都只是提供了多线程处理i/o能力，在应用层也可以实现自己的i/o模型函数。在操作系统api级别，操作系统提供了一些I/o模型函数，很多的vm语言又会利用底层系统提供更高级更方便的i/o处理模型，最后在应用层我们做软件的时候，也可以通过合理的使用线程池等线程工具实现项目功能更加丰富的i/o模型函数工具。在此，不管在哪个级别，都可以归咎于下面这些分类上。

**从前的讨论中也可以看出i/o模型的作用对象是当前调用i/o模型的线程，这个i/o模型函数决定了调用它的线程会做什么动作**。

# 同步堵塞模型

最原始的i/o模型，是操作系统内核提供的基本能力，我们直接调用socket函数进行堵塞，或者读文件打开，当前线程会直接堵塞直到i/o完成该线程才会被操作系统内核唤醒。而所有的i/o模型函数都会利用操作系统内核的另一个功能，返回文件描述符，检测是否完成。所有的堵塞模型函数，都不会自己创建线程，而是使用调用这个函数的线程，堵塞模型函数做什么，当前线程就做什么不能继续运行下一条指令。

以下是各种同步堵塞i/o模型的实现：

## 只监听一个i/o文件

在Linux系统中，提供了read i/o模型函数，这个函数使用了操作系统的另一个能力，会让操作系统i/o文件直接返回文件描述符，不断的轮询是否完成，这样也会造成当前线程停止往下运行，但是当前线程其实本质上没有堵塞，只是在不断的循环检测是否完成i/o，这对于直接堵塞效率会更高，但是对于其它线程和系统整体而言，这浪费了许多cpu性能。这种方式实现简单，我们在应用层也可以很轻松的实现。

## 监听多个i/o文件（多路复用）

是可以同时监听多个i/o文件的函数，当前线程会一直不断的遍历多个i/o文件是否完成。全部完成了再继续执行，linxu中的select，poll,函数都是这样的功能，其中select函数是采用数组，可以监听的i/o文件数量有限，poll采用链表容量不限。这种方式其实也很简单，我们再应用层用java或者c++语言也可以很轻松的实现。

# 异步i/o模型

这种模型函数，都会自己创建一个新的线程，通常都只能监听一个i/o文件。它的实现也就只有下面的一种方式。

## 信号驱动

i/o模型函数，会新创建，或者使用线程池中的其它线程，去不断的判断文件描述符是否完成，或者用一个线程直接堵塞线程。这样并不会影响调用函数的线程正常继续运行，但是需要给这个i/o模型函数传递一个回调函数，当i/o完成以后，这个新的线程会运行调用者线程的函数。就好像给调用者函数一个信号。

操作系统Linux提供了epoll和aio都是这样的功能，其中aio是内核本身提供的功能，epoll是系统提供的库。windows下有iocp。

这种模型，被用于大量语言和框架中，比如node所有的i/o行为默认都是这种方式。spring webflux是一个java实现的i/o处理框架。这种模型也有缺点，如果一旦计算量过大，少量的i/o线程是不足以支撑的，会影响整体的执行效率。



# 实际中的i/o处理

在应用层，我们写代码的时候，如果一个语言是全功能型的，也就是说提供了操作系统的所有特性，比如java，c++，我们通常会直接创建一个新的线程处理i/o，而在nodejs中，这是不行的，我们被强迫使用异步i/o模型，或者同步堵塞模型。

在js语言的模型中，提出了事件循环，其实本质上这是异步i/o 和 同步多路复用的组合方式，用户线程是单线程的，但是这个线程的行为，不是完全由用户自己的指令控制的，其中有一些函数可以返回promise对象，这样的对象，内部的指令代码js运行环境不会立即执行，用户线程中用户脚本完全执行以后，用户线程还包含了隐含的循环这些promise对象进行单线程的轮询遍历执行，特别的对于用户线程如果其中有一些指令是系统级别的I/o调用，会不断的检测遍历是否完成这个i/o如果完成的话会执行它的回调函数。如果js可以将promise独立设置为线程使用，那么还要考虑线程的局部内存，内存屏障等事情，语言运行底层能力会变的更复杂，系统执行环境也会变的更大，js就会失去作为一个轻量级语言的特性。