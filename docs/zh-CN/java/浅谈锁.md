# 前提

在讨论锁之前，先讨论一下锁具体是什么，在学操系统的时候第一次遇见“锁”这个名词，其实一直觉得这个概念挺模糊的，听起来只是一个机制，在看了翻阅了一些国外的操作系统教材后我发现，锁(lock)有另外一个名字叫mutex，他们的定义是原语（primitive），是对信号量的一类操作，信号量的普通操作原语叫做Semaphores ，真的很会起名，信号量是一个变量Semaphore，不加s，加了s我本以为是信号量集合的意思，没想到是原语的意思，所以英语名词加s，并不一定指多个变量，他很可能引申出一些别的含义；

因此，锁是一种操作信号量的原语，信号量机制是解决进程，或者线程同步的基础；信号量没有特定的含义，只是一个变量，进程的同步顺序要依赖信号量的值，一般指的是资源数量；

因此，我们在关注某种信号量的时候，只需要关注这种信号量的原语就好了，原语决定了这类信号量的性质；

primitive 这个名字翻译成原语，感觉很不合适，还有，primitive 这个单词在书上很少自己出现，而是用 synchronization primitive，primitive 意思是某一类事务中，最早的一个，如果是人就是最早的人，如果是苹果就是最早最原始的苹果，做名词的时候是一个最早代词的含义，synchronization 在计算中指的是 操作行为的操作序列，那么synchronization primitive 的准确含义就是，原始操作同步序列；为啥翻译成原语，我是不懂了，在下面的文章中，我们把原语叫做原始操作同步序列；这个操作是指操作信号量；

锁 lock 一个名词，为什么可以指代一个 synchronization primitive ，synchronization primitive是行为集合，lock 可以指锁定行为集合，那么此时lock就成了代词了，英语这个花样真是66的；

# 结论

从前面的讨论，我们得到了：

- 信号量，是一种控制线程同步的变量，线程根据这个变量控制进度；
- 原始操作同步序列，是一个操作信号量的最基本的集合；
- Semaphores：普通的原始操作同步序列；
- **锁**，是一种原始操作同步序列，他和Semaphores的区别是信号量的，两个synchronization primitive ，上锁和解锁，只能由同一个线程进行，而Semaphores可以由别的线程来完成这一步，这也是Semaphores中二进制信号量和互斥(锁）信号量最大的区别；



# java中的锁

在java中，前面所说的原始操作同步序列，synchronization primitive，在这里被具体化成了对象，对象中包含了信号量和synchronization primitive 基本操作；

锁的作用范围，功能，都是不一样的，实际的锁，都在java.util.concurrent 包下，有两个接口，多个类，还有一些具有锁功能的集合；这些集合本身的操作可能就加了锁，或者每个元素加了锁，不用再自己去写这样的集合工具类了；

1. Volatile 不是一种锁，只是一个变量同步功能；
2. Synchronized ，是标识符，加了标识符，jvm会对这个代码对象编译的时候添加一些额外的操作语句，对方法进行加锁，有偏向，轻量，重，三个状态，这些状态的区别是，锁在生效的时候，判断是否加锁的代码不同，重的判断方式是最复杂的，jvm会根据实际运行情况，来用不同的判断方法，一旦使用了更复杂的方法，那么这个锁就会一直使用这个办法，偏向是默认只有一个线程，轻量是默认，没有竞争，线程都是一个执行完下一个继续执行（很多文章上来就是偏向锁，重量锁原理的，连基本的使用场景都不说也是绝了，其实没有必要先知道原理，要先知道使用场景，有 需要的时候再了解原理）；
3. java.util.concurrent 包下，有专门的锁接口和对象，提供各种场景下的锁，有不同的功能，基本能满足所有需求，再实际使用的时候，可以搜某种需求，然后加上java 去寻找类；也有一些线程的加了锁的集合可以用，甚至是基本对象也有对应的锁类；**有一些并不是锁，比如Semaphore，它的信号量的值，是可以由多个线程做同步改变，而不是它自己**；**锁，只在locks包下，别的一些类不是锁，而是信号量同步工具类，集合都是加了锁，不是信号量**；
4. 对于，重量级锁，轻量级锁，自旋锁，，，，这些都是java自身的一些锁中的状态，他们的分类是根据锁的执行状态，并不是根据锁的状态来区分的，对于使用锁编码来说，没有什么作用，不需要知道这么多名字，他们的官方文档中也没有把这些执行状态成为锁，还有悲观锁，乐观锁，更是扯淡，也是根据锁的执行方式来做区分的；
5. cas是一个思想，比较；aqs是java中的一个同步队列接口；把cas看作一个函数的话，他有两个参数，一个参数是期待的值，另一个参数是现在的值。是不是好像只是比较这么没有set呢，含有cas对象的内置函数，cas内部会进行设置的也就是set对象自身，当然外部判断cas的布尔值在进行别的操作（set）也是可以的，总之cas就是一个比较思想，不断的循环（循环不是cas的一部分）。



# java中锁一些观点

- 观点一： 我觉得提出，可重入锁，公平锁，重量级锁，自旋锁。。。。的人就是傻逼，这些只是锁的执行方式，而不是锁的特性，只说这些锁的底层的归类，有什么用的呢，又不是很难的东西，只是一些技巧，锁的存在本来是为了解决特定场景的，反而现在为了八股去背他们的实现，而不是了解，特定场景下的锁，需要对集合中的每个元素加锁需要什么锁。。。应该根据一个场景，有什么锁类，然后去类比使用；

- java中的锁，本质上还是信号量，可以完全按照信号量的使用去思考锁的场景，只不过，解锁只能由占用线程的自己解（特殊处）；
- java中，对于**使用锁的场景**，**也就默认了是线程互斥关系场景**，而不是线程同步场景，只要每个线程肯定会执行上锁和开锁，两个synchronization primitive,肯定会执行成功，不可能死锁；除非是设置了多个线程互相配置的情况才可能出现死锁，这个时候信号量就不是锁了；**要确定好，使用的是不是锁，不是锁而不是别的信号量的话是可能有死锁的**；



# 锁与别的信号量

锁，是一个二值信号量单位，读写锁，是一个包含了二值信号量的信号量集合，写锁是二值的；得不到锁就挂起，等待释放锁的呼喊；

很多情况下，有很多不是二值信号量的逻辑，这些东西是不能够称为锁的，**如果不严格区分信号量，那么会面临不知道会不会带来死锁的风险**；

**锁，并不一定，得不到就等待，也可以直接结束**；根据实际的业务情况做决定；

**锁代表的资源数量只有一个。**这种资源在编程是是最多的，所以锁被用的最多。

# 分布式信号量

这里说，分布式信号量，是因为，这些工具方法，并不是非要是锁，也可以是别的信号量；虽然一般多用于锁；

分布式信号量面临的场景是，多个服务器上，有相同的实例，这些实例不在一个主机内存上，但是他们本来应该是同一个进程内的线程的，这个时候他们要想有信号量，就不能使用java提供的信号量了；这个时候就需要一个他们都能访问到的中间媒介，这个媒介可以是数据库，也可以是redis, ZooKeeper 等；

- 这里的线程，遇见有锁的状态多是，直接死掉，而不是等待，也可以等待
- 如果是选择直接死掉，就没有必要有手动释放锁的primitive 了，所以多使用redis，使用set 加 time ，来主动释放，setnx可以判断是否有key，但是无法设置时间，而set可以 设置时间又无法判断，如果 判断是否有值，设置值，设置过期时间，**三个动作不能作为一个原子整体**，就可能会发生死锁（primitive 本身没有实现），或者发生一些不符合预期的事情，所以一般在redis中插入lua脚本，使用redis命令来触发这个脚本，执行原子操作；执行**多次redis请求会增加负担**；

- Zookeeper 比起redis能达到，顺序的作用，让多个服务同时有顺序的执行，而不是一个执行完下一个才能执行；因为它的结构是有层次的，redis没有层次，用redis来达到相同的效果，需要做很多工作；



# 业务信号量

一般也是锁的情况；

java中提供的同步工具，都是针对线程而言的，多个线程之间没有任何区别，但是有时候，多个业务可能走同一个线程，多个线程在运行的时候有了身份，而不再是统一的面貌，这个时候就需要有一个新的信号量了，而不在是线程信号量，一般使用redis来进行设置；

**其实为了方便，而不是非常的高性能，一般都是先使用redis查一下，有没有，在进行设置，值和过期时间，而不是用lua脚本，多次请求也没啥，流量不高的情况下**；



# cpu的基本知识

1. cpu主频，是cpu运行的基本频率，每秒可以执行多少个指令；
2. cpu利用率，在windows中，是以60秒为单位，统计该时间内，cpu实际执行指令的时间；
3. cpu时间片轮转调度，这是现在cpu最基本的一个调度算法，操作系统为所有的线程进行轮询执行，每个线程的时间片一样大；所以线程越多，等待cpu的时间会越长；还有一个值得注意的是，死循环并不会导致系统崩溃，因为一个线程是有自己的时间片的，顶多会提高一下cpu利用率；真正系统崩溃的是，内存被吃光，i/o被占满，等资源被占满；
4. 并行和并发，并行是有多个cpu核心才能执行的事，并发是多个线程按不同的顺序一起执行，并不是真正的一起执行；



# 什么需求会用到多线程

我们从线程的角度来看这个需求

1. 开启无限个线程的需求，这样的需求多来自网络请求，比如web服务器，游戏服务器，每个客户端发送一个请求，为了给每个用户独立的程序服务，需要为相同的业务代码，开启一个独立的线程请求，线程的数据都是独立的，互相互斥；这种场景下多个线程执行的代码逻辑是一摸一样的，同样的代码；
2. 执行，计算型任务，电脑有几个cpu核心就开启几个线程，因为开的多了也没啥用（通常还会多一个线程，用于避免意外）；这种情景，可能是解析一个很大的文件，把文件分部用不同的线程执行；也可能是执行一个计算量很大的统计，需要多个结果的聚合；这个时候，多个线程执行的代码可能是同样的逻辑代码，也可能是不同的；设定为cpu核心数，要保证计算量是恒定的，不是可能会不断的增加；
3. 执行，有i/o等待的任务，i/o不一定是网络请求，与任何介质交互数据的行为都是，磁盘，内存，网络端口等；当然是越多越好，但是太多的话，会导致其它任务的线程等待时间过长，目前普遍的做法是 设置cpu线程核心的2倍（其实是不准确的，但是这样也无妨，要看实际总共有多少业务在跑）；这个场景，很可能是，一个功能，需要从多个i/o 存储部分取值，综合结果，每个步骤可能需要上一个执行完，下一步才能执行；比如文件上传和下载，用这个办法，一个线程不断的接收数据，一个线程不断的保存数据到磁盘；



# 线程安全的需求体现

和操作系统课本中提到的一样，当有下面几个需求的时候，就有线程安全的需要；

1. 多个相同代码逻辑的线程，访问同一个数据源，数据只能被一个线程获取，获取到以后就数据这个数据，但是来源只有一个变量；
2. 多个不同逻辑代码的线程，访问同一个或者多个数据源，根据数据源的值，判断执行不同的分支逻辑；当然也可能只是取数据，简单的加工数据；

# 什么是线程安全

在说线程安全的时候其实是个简化词语，应该是线程安全的操作，或者线程安全的对象。

线程安全的对象指的是，多个线程访问这个对象，都能按顺序，的得到应该得到的值。直接加锁，只让一个对象获取是一个安全的行为，但是有些时候不需要这么重的行为。

线程安全的方法是的是多个线程同时执行这个方法，他们能够有顺序的不出差错的执行或者访问变量。或者多个方法有顺序的执行。



# java中可以如何利用线程，如何保证多线程交互同步正确 

如果是开启无限个线程的需求，大概率不会需要这样的需求，这个需求是开发服务器，而不是利用服务器写业务；写业务是可能遇到这样的需求的，数据用户的大量数据，利用多个线程来执行，这些线程在执行的时候，可能数据数据之前的同步，我们并不需要自己写锁，写信号量，java提供的足够多的工具类，为我们执行同步线程做操作；这些工具类，都在`concurrent `包下，有些类并不是锁，而是信号量工具；要区别他们的区别，请看我的其他文章；
