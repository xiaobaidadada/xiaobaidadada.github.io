**锁**，这个字原本指的只是一个物理上的物体，家里门上的锁。在引入到其它领域后，在计算机中，不同的预警下，锁可以是一个机制概念，也可以是一个变量。机制概念比如，分布式锁，乐观锁，悲观锁，行锁，他们都涉及到多个线程访问同一个变量的问题，就像多个人访问同一个可以被上锁的大门，不同的锁就像，电子锁，梅花心锁，人脸扫描锁一样，一把锁的功能，通常也不能由自己来实现，如果一个锁是简单的，比如需要钥匙打开的锁，他自己就可以实现自己的开关，但是电子锁就不同的，他需要电池，人脸识别锁可能还需要联网。在编程中，锁的实现也是可能需要多个组成才能实现，比如乐观锁，我们需要使用while循环，来访问辨别一个变量是不是我们期待的值，那么这把锁是这个对象吗，还是while循环，**核心当然还是这个变量，但是while循环语句就像锁的电池**。还有分布式锁，我们需要一个保存变量的地方，当然这个变量我们也不会直接操作，而是需要一系列的函数组成。

因此在计算中一个锁的组成需要以下：

1. 概念，这是必须的
2. 核心变量，信号量标志数据，表示锁的状态
3. 辅助执行语句，可能需要手写，而不是函数。



# 进程中的锁

进程中的锁，指的是多个线程所要访问的锁。这里的锁，指的是一个变量状态，通常不同概念的锁，会用不同的方法来辅助实现上锁解锁操作。

**在代码指令中，释放锁是简单的。但是上锁，是很难实现的，上锁，一定会两个操作。**

1. 判断变量是否是预期值（有没有被锁），
2. 进行上锁。

1和2，必须保证是原子的，才能完美上锁，否则就会出现，两个线程都对一个变量判断没有上锁，然后都进行加锁，同时觉得自己都已经上锁了。怎么解决上锁的问题呢，首先想到的办法肯定是synchronized或者lock接口的实现类。其实本质上上锁的办法只有一个，就是进行cas操作。



**cas**操作是比较和替换，必须提供当前获取的变量值，预期当前获取的变量值是多少，希望变量被更新到多少。java中的cas是依靠Unsafe类来实现的，底层是c++代码，预期变量也就是对象的值，必须是和预期的值一样，才会更新到指定的值。这个操作使用硬件指令，保证了多核cpu只有一个线程可以成功。从代码逻辑层面，是无法做到的。



对于cas还有一个aba问题，两个线程同时cas，变量最终的值又回到原点了，但是我们是上锁，对于上锁而言，两个线程，不会将变量从一个状态变成另一个状态，只会是递增的新状态，所以不会出现aba问题。



这只是上锁操作，在java中的很多锁工具，如果cas失败了就重试while这个称为乐观锁，cas失败了直接入队列，成为悲观锁。



Volatile关键字，只保证了可见性，但是没有保证两个进程同时修改只有一个成功。我们上锁，其实不用不到这个关键字也可以。他只用于第一步的判断操作。



每个锁，还要注意释放，如果只是上锁没有释放锁也不行。

# 分布式锁



对于进程中的锁，每个锁的变量都在内存中的，多个线程可以直接访问，但是如果变量是远程数据库中的一个记录呢。对于业务代码而言，这个场景是非常可能会出现的，特别是分布式项目。



我们可以对数据库中的记录用sql的行锁来进行，但是这样会不可读，我们更希望在代码层面上锁。利用常用的内存工具redis来实现。

还是那个问题，对于上锁而言，还是要分前面的两步进行。



redis有一个和cas很类型的操作，叫做SETNX ，是原子性的。但是我们通常还会加上超时时间，自动释放锁。这两个操作通常会让redis执行lua脚本，lua的执行是原子性的，如果只是设置了锁，然后程序崩溃了，没有设置过期时间，那么别的客户端就再也获取不到锁了。但是这两个操作的时间是很短暂的。出现这个问题的几率不大。



采用上面的自动释放锁，会出现程序还没运行完锁就被释放了，这个问题我们才可以客户端自动续约的方法，用另一个线程不断的再过期时间到达前进行续约，但是这样的话，就必须要释放锁，否则就会产生死锁，不过我们可以设置一个最大业务续约时长。



以上的操作**Redisson** 这个库都已经实现了，还提供了优先级的方案。

其实我们可以确定一个业务肯定会在一个时间内操作完，就不需要看门狗续时了，如果业务超过某个时间我们就假定已经出现问题了。如果我们可以确定自己一定会释放锁，其实也可以不加超时时间，不过我们要假设会有系统挂掉的情况，这个时候我们要设置服务状态在缓存中，然后状态使用心跳，执行删除锁的操作。



