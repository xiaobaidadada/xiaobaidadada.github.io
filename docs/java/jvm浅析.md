# 说明

本文是浅析，不会过多说明某些数据具体是什么，结构是什么，而是从高度抽象有什么东西，表达出jvm的运行机制，具体的细节可以从很多资源中自己查询。当面对一个很庞大的系统的时候，就是应该先整体知道有什么，然后在具体深度细节，不然会感觉举步难行。接下来的表诉可能不是很严谨，但是如果很严谨的表达是需要全部知道细节才可以的，所以假设没有知道全部细节，采用这样的语言表达是很好理解的。编写文本我也看了相当多的jvm相关的书籍才有的这样的感悟，太细并不是很好的选择。有些名词如果实现没见过，可以搜一下。

# JVM是什么

Java Virtual Machine，本质上是java system runtime，[runtime](/code/runtime.md)就是程序本身起引导作用的，在运行期间也一直起着作用，提供编程语言的特点实现。虚拟机不同于一般的GO或者C把程序代码本身和运行时系统作为一个整体打包成二进制，一个程序需要编译，链接，形成二进制程序。java虚拟机只有编译，没有链接，链接是在运行的时候进行的，而且java编译的结果只是描述，并不是真正的二进制指令，在运行期间除了链接，还会进行真正的转译。

但是java不同于js，或者python这种脚本语言，不是一行行的解释执行，java是整体解释成二进制，所以如果java如果在运行期间没有新的对象加载，那么所有的代码都变成了二进制的，整体运行就是二进制的，速度并不会很慢。

vm执行的过程，这里用一个不是很恰当的过程举例描述一下。假设jvm是c++实现的，那么jvm就是用c++写的一个程序，jvm运行的时候，需要一个代码文件，这个文件中有一些参数，然后读取这个文件，从上往下一行一行读取，就是不断的if，符合一个条件就执行一下语句，这个文件可以被加载成变量而不再是字符串，成为自定义的内存中的数据结构，这样遍历执行的时候效率会更高。所以java慢的原因就是本来直接执行的一个语句，java多了很多的if判断语句，对于python这种语言可能它的vm每行执行都要先转译语法再进行if判断。脚本语言占用内存普遍大也是因为使用变量作为程序功能指令的内存用的太多了。这些变量占用的内存就是jvm相关书籍中所说的运行时内存。不管是堆，还是栈什么的，实现都只是一个c++中的结构体，用一个动态内存指针保存着数据。



# class文件结构

jvm加载运行的指令就是class文件，class文件的格式是特定的，为什么不直接翻译.java代码文件，而要用这一步编译，并不是为了提交加载代码的效率，而是提供这样的一个功能，多语言运行平台，可以把class文件的结构看作一个语言，汇编语言。然后java，groovy,jpython这些语言都可以编译成class文件运行。



这个class文件结构不是用文字描述的，而是用二进制的字节描述的，但是部分字节仍然是采用字符值保存的，整个文件保存了相当多的信息，这些信息是按顺序从前往后排序的，保存的数据要么是数值，要么是表（这里的表的含义是列表，列表这个词的含义是有顺序元素，但是中文用的不多，和表格没有关系）。用二进制表达表结构，每个表都要先声明自己的长度（表达后面多少范围内的字节都是属于自己的），然后定义类型，定义数据，只要满足先定义，后表述，就可以实现任何语言的表达。这里说明class文件的结构仅仅是说明有哪些元素，并不会具体分析其组成。

结构从前往后具体的元素有，魔数（一个特殊值，用于表达文件的类型，很多问价都有就像文件后缀一样的功能），然后的class版本（规定版本低的jdk不能执行比他高的版本的class），jdk版本和class的版本没有必须的对应关系，然后是常量池，就是一个列表结构，保存着某个java类中所有用到的常量，每个常量都有类型，具体表达也是从前往后先定义长度类型再定义值，这些常量用于被后面的变量引用。然后是类索引，索引，接口集合索值表，然后是字段表集合，保存着所有对象的变量字段，然后是方法表，方法表几乎和字段表一样，方法的指令用属性表的code字段存储，属性可能存在于任何一个数据中（类索引，接口等等），属性表的格式是特定的，也允许扩展字段。

所以一个class文件，看起来就是一个java类代码的含义的完全表诉，只不过采用了严格的数据结构保存。没有什么稀奇的。

# Jvm如何加载class

加载对象，分很多阶段，加载，验证，解析，初始化等。很多书上的第一个阶段叫加载，其实就是加载class文件，只不过为了打字间断都写加载吧。

class是被加载器加载的，jvm中的boot加载器是最高级的，就是jvm代码本身自己加载，他会扫描java_home下的类，然后还有一个加载器使用java类实现的叫扩展加载，然后更低级的是自定义的加载器，需要继承这个类。

jvm采用父委托模型加载（也叫双亲委托，双亲是不知道谁瞎起的名字），意识就是所有的加载器都有在一个链上，最高级的节点是jvm代码提供的加载器，加载一个类的时候，会首先让父加载器去加载，然后再自己加载，这样做是为了避免在不同的类文件目录下有相同的类，如果自己能加载到一个名字的类，父加载器也能就会保存，进制启动。

如果每个类加载器是独立的，就很有可能出现一个class文件被加载了多次的情况，所以在双亲委托模型下，一个类的全称除了包名还要加上类加载器。

但是spi机制和OSGi模块化实际上破坏了这个机制。spi就是一个文件定义一个类名，加载器去加载这个文件内的类，而不在让父加载器去加载了，这样可以实现，定一个类加载器文件名字，提供不同的版本的实现，以后被依赖的项目不用修改代码，只需要修改jar包就行了。spring也提供了spring spi机制，这也是springboot的实现的基础功能。

加载完class就会把class保存到jvm的内存中了，具体的对象的生成是直接读取内存中的这些类的信息生成的对象。所以类级别的static只会执行一次。在代码执行的期间，class文件才可能被加载到，而且可以用class.forname主动请求加载类。所以这也是影响java运行效率的一个很大的因素，但是这样也有很多好处，比如lcass可以加载，可以实现自定义类加载器远程http获取，这样就可以加密代码了。



# jvm是如何执行class的

接下来假设jvm就是c++实现的一个程序。

## jvm的运行机制

jvm只允许多线程的，像pyhton和js这样的脚本一行行解析的语言就不支持多线程，而且java的多线程工具是目前几乎所有编程语言中工具最丰富的语言，所以虽然是一个需要虚拟机的编程语言，但是相当多的都采用java开发，比如很多大数据软件都是使用java开发的，还有es数据等等。就是因为java的多线程支持很好，由于直接全部编译成了二进制代码，运行效率也不会很低，就是每个语句执行多了一些if。

jvm的执行模式是支持多线程的，所以jvm的作用就等同于一个真正的操作系统一样。每个线程都要独立申请一个真正的线程，每个线程都有自己的独立变量（线程内存），整个程序有一个公用的变量区域（主内存）。由于java支持多线程，我们甚至可以利用java写一个支持多线程的vm，在jvm上又执行一个vm。所以在实现这个模式的时候，我们可以用java语言的去看待这件事怎么做，怎么实现的。

这里就会涉及到一个主内存和线程内存的文件，这个问题在真实的物理机操作系统中，也是一个很明显的问题，如果线程之间需要互相交互变量，他们之间的媒介就是进程主内存，所以采用的机制都是每个线程内存直接拷贝主内存中的数据，但是又会出现线程变量修改同步的问题，这个同步问题的解决各种操作系统都是采用内存屏障的机制解决的，屏障在计算语义是一个用于同步的函数，内存屏障就是用于内存之间同步的函数，在屏障函数执行的过程中，他所设计到的变量不允许别的线程读取修改，分别代表写屏障和读屏障，执行完再允许比的线程使用。这样就可以解决同步问题，内存屏障这个函数设计到好多语句的执行。

java中，如果对一个变量添加了vilate关键字，这个关键字的相关语句的执行前都会执行一个特殊的语句，用于实现内存屏障。

另外jvm会对指令的执行顺序进行优化顺序，这是为了让进行i/o较长的语句尽可能的先执行，因为他们先执行就不会用到cpu，这段时间可以执行需要cpu的语句。vilate并不会破坏这种优化，只是操作vilate的变量的时候，别的线程都不动了，所以执行的结构就好像，vilate前后的指令顺序不会变一样。但是前面的后面的直接的顺序还是可以变的。

jvm从main函数开始执行，默认为main函数提供一个线程。

## 把class放到具体的结构体中

这一步就是c++程序，读取class文件，从上往下一行行的读取，把特定的信息放到特定的变量中，class肯定是全部放到主内存，而运行期间线程需要的数据，都单独开辟一个空间来保存数据。

很多书上把java的内存模型说成，堆，方法区，栈三个结构。这其实jvm就是由c++/c实现的，c++的内存模型就是由堆和栈等结构组成的，一般的教科书并不会说c++的内存模型，但是每个语言都有自己的内存模型。堆的含义是，可以任意分配的内存区域。c++的堆的申请就是普通的申请内存的函数，每个c++的堆大小由操作系统决定，32位的windows系统提供的大小是2G。java中的堆和栈也是同样的含义。这里的堆和数据结构中的堆含义完全不同，为什么这里叫做堆，[编程语言 - 为什么用于对象分配的主内存称为“堆”？- 软件工程栈交换 (stackexchange.com)](https://softwareengineering.stackexchange.com/questions/186705/why-is-the-main-memory-for-object-allocation-called-the-heap#:~:text=This information at least dates back to Knuth,its more traditional sense related to priority queues.)应该是最开始哪个SB写的吧，后面的人跟着错了。

堆是放在主内存中的。堆栈这些数据区域，是jvm这个程序自己提供决定的，具体是连续的还是顺序的都由具体的虚拟机自己决定，但是抽象使用上都需要是连续的才行。实际上所有的区域都是用c++结构体，加一个内存指针表达的。

相关变量的存放都是采用句柄的方式，具体的变量引用这个对象的时候是引用句柄，因为对象的内存位置是可变的，句柄指向一个对象不会变，各种语言框架都提供了这样的概念。就是固定一个位置而已不要想太过。

每个信息的存放都有自己的格式，对象的存放就包含了对象头，分代信息，锁状态等，对象的具体表达也就是一个c++结构体。

### 类信息的存放

类的信息的存放都是放到堆中，因为随着程序的执行，类可能是不断增加的，堆的大小是可变的。不够了jvm自己使用c++申请内存函数申请，但是不能超过jvm初始化参数规定的最大值。这个存放类信息的地方叫做方法区。存的时候，也会执行类的静态方法。

### 函数内局部变量的存放

这是放到每个线程独有的内存区域的，这个区域其实也是堆，可以变，但是由于是栈的使用方式，也叫栈堆，每次函数调用栈就会增加一个栈帧，保存这个函数此时所有的变量信息，有的是需要从主内存拷贝过来的，指令代码也在栈帧的特定位置处。每个函数调用栈都会去申请新的内存，如果申请不到了，就会报错。所以java的递归深度是没有数量限制的，但是有内存大小限制。

线程独立的内存还会提供一个程序计数器，也就是一个c++变量而已。

### 不受大小限制的内存

我们能通过java运行参数控制的只有堆栈大小，但是jvm这个程序自己本身也需要运行需要空间，这是jvm自己决定的，这么大的vm运行起来需要的变量肯定非常的多，这个不受限制的内存空间，只受低层操作系统提供的限制，也可以用java语言特性中的nio来申请使用。



## 堆垃圾回收管理

java语言 提供的一个很大的特点就是不需要java程序自己管理内存，而是由jvm来管理，go语言也提供了这样的功能，go语言是把动态内存管理的代码和程序本身直接都打包成了一个二进制代码执行。

垃圾回收只会堆这个数据结构进行回收，回收里面的对象，未来可能不只是对象。因为堆存放所有的类的信息，还有对象，类的信息（方法区）目前也不会被回收。

回收对象使用的内存，首先要判断对象是不是还活着，方法有引用计数，和可达性分析两种，所有语言都是这两种。引用计数无法解决循环依赖的问题，一般用的系统都是程序自己本身（比如你自己写c++程序的时候，自己再写个垃圾回收判断的子线程程序），而不是vm软件可以采用的方式。jvm中很多垃圾收集器采用的可达性分析，都是先通过永远不会被回收的永久代对象，从而分析对象的可达性，把没有被标记可以到到的对象进行回收。

java对象这个结构体，有一个代的概念，记录自己属于第几代，一代指的是一个对象集合，在一次垃圾回收触发执行的时候，没有被回收的所有对象都属于一代。

jvm把代分为了三个层次，永久存在的代，这个代的代表的对象永远不被检测回收，存在很老的代，这个代是躲过了一次或者多次垃圾回收的对象集合，新生代，指的是所有刚创建没有经历过垃圾回收的对象集合。不同代的对象，会使用不同的垃圾回收器回收，使用不同的策略。

确定完垃圾对象，还要采用具体的策略进行回收，不同的垃圾回收器使用的线程同步策略，内存管理策略都不同。而且不同的代垃圾回收器可能不同，大多需要两个配置使用。

### hotspot虚拟机与它的垃圾回收

hotspot是大多数jvm使用的虚拟机，sunjvm和openjdk都是这个虚拟机，使用java --version可以查看使用的什么虚拟机，不过jvm也不一定会提供相关信息。

hotspot提供的java命令参数分为两种 

1. 标准参数，所有的虚拟机都支持的参数，打一下java命令就可以查看所有的标准参数
2. 非标准参数，hotspot支持的，使用java -X 可以查看都支持什么参数，这些参数都会带个-X前缀，-XX双X的是较为高级的参数。



hotspot有两种运行模式，客户端和服务器，客户端的编译不会编译的很彻底，可能没有把class文件全部编译为变量，一部分可能还是采用字符串保存，执行的时候再编译，服务器模式是默认的，会彻底编译，客户端模式启动快，用于临时测试一下功能还是可以的。

对于具体的清理内存的方式，所有的新生代回收器都是使用标记复制的方式，所有老年代的策略都是使用标记整理的方式（先标记清除），单纯的标记清除会产生很多内存碎片无法利用，年轻代大多数对象都会被删除，所以直接删空全部区域，复制存活的下就好了。

#### 客户端模式

处理新生代对象使用的是，serial 垃圾收集器。老年代是serial  old，这种收集器执行的时候，客户线程会一直暂停，因为垃圾回收的时候如果对象还可以被使用，会出现很多异常情况，用户线程不可能一直不停止，至少在判断对象是不是垃圾对象这个阶段要暂停一下。serial是从头到尾客户线程都要停止运行。而且是单线程的

#### 服务器模式

不同的版本使用的还不一样，可以通过java命令的高级参数选择具体的垃圾回收器运行程序

1. CMS 不属于任意一个版本，是一个可以选择的版本，他是一个多线程运行，同时和客户线程并发执行，可以最高效率的提高客户线程的比率，这样会让垃圾回收的时间变长一点，而且期间会影响客户线程的性能。是一个用于新生代的收集器。
2. ParNew 是serial的并发版本，执行的所有客户线程从头到尾都要停止，parallel scavenge 基本和ParNew一样的功能，但是是一个可以通过参数调节一些数据，也是用于新生代，一般配合parallel old老年代收集器一起使用。这个组合是 jdk9以前的默认配置
3. G1,garbage frist这个名字起的很霸气，这是jdk9默认开始的垃圾回收器，他适用于所有代，他将堆内存划分为不同的区域，对每个区域进行分代，使用CMS的办法，尽可能的提高用户线程执行的吞吐量。
4. Epsilon 是一个不进行垃圾回收的收集器可以选择，适用于非常小的程序，没什么新生成的对象，或者可以反复重启的程序，保证客户线程的稳定性。





# JMV调优

调优目的是避免内存泄漏，减少GC次数，避免老年代GC照成的用户线程停顿。

方法有很多，但是也只能对垃圾回收进行调优，别的都是jvm自己的事，jvm如果做到了高度的jvm执行可选项这也会影响性能的。

gc日志启动，在 JDK 9 之前使用-XX：+PrintGC，JDK 9 后使用-Xlog：gc，加了这些参数会启动日志记录

 

运维命令，jps 正在运行的java进程查看。

jstat 用于监控某个java进程运行状态的命令。

jinfo 查看进程的配置信息。

jmap 生成java堆快照。也可以设置溢出自动生成的参数。

jhat查看 堆快照的工具。一般不会用。而是用一些专业的工具来查看。

jstack 栈快照。

hotspot还可以使用实时的监控插件。
