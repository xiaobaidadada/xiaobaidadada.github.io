# 数据类型

字符串（也可以是数字），hash，set，有序set；列表；

除了基本数据类型以外还有：

bitmap 位图（底层字符串）

geohash的空间坐标



# 事务

使用multi和exec可以开启事物和提交事物，事务开启的过程中不会直接执行接下来客户端的命令，事务提交后这几个命令才会一起执行。

中间可以使用discard放弃事务。

watch和unwatch可以在开启事物前，设置一下如果监视的key被修改，事务则会停止。这个事务无法强制规定别的线程不修改key。

另外redis是可以执行lua脚本代码的，也可以保证事务性。可以做到不被别的线程打断。



# 持久化

RDB的方式是快照，可以设置redis自动进行快照保存，也可以用命令bgsave触发；过程是父进程fork一个子进程（由于redis单线程特性，这个时候redis无法处理客户端的请求），内存进行快照副本拷贝，子进程把数据按照不同的列表以二进制的方式保存到rdb文件中。



AFO也是一种持久化方式，RDB和AFO互不影响，AFO需要在服务端开启，开启后会一直保存redis的命令。恢复也是不断的执行所有的redis命令。但是这样会导致AFO文件过大。AFO文件太大可以重写，可以在服务端设置文件大到一定程度自动重写，也可以使用bgrewriteaof命令手动触发。重写也是fork一个子线程，这个时候redis还是无法为客户端执行命令了。之后父线程增加的命令会最后在子线程结束后，写入AFO文件进行回放。

还可以开启重写混合，这个时候重写AFO文件是按RDB的二进制覆盖的，之后才会进行AFO命令的加入，这样会更快。



# 主从复制

可以设置一个主服务器，多个从服务器，首先启动多个服务器，向从服务器发送主服务器的信息，使用slaveof命令。那么从服务器就会请求主服务器进行数据库同步，主服务器会提供一个RDB快照，以字节偏移的形式发送给从服务器避免断机重发，之后在保证命令的同步。从服务器这个时候只能读，写的话会报错。每个redis服务都有自己的id；采用心跳机制检测是否还在链接。

一个写多个读，更能保证性能，redis毕竟不是多线程的。这样其实还起到了数据备份的效果，没必要频繁RDB了。AFO不用开了。



# 哨兵

哨兵是redis服务的一种模式，这种模式下服务不在提供读写而是检测主节点，从节点，哨兵之间也会互相知道信息，当主节点客观刮掉以后，哨兵根据配置的心跳机制，共同选出一个从节点作为主节点，向其它节点发送命令。一般为奇数，避免出现选不出来的结果。

可以使用Jedis等一些客户端，实时和哨兵进行通信，获取哪个节点是主节点。



# 集群

集群部署的主节点之间都会保存各自的信息，他们会把所有的key进行分solt，客户端向任意一个服务发送请求获取key，服务会返回一个实际保存key的服务地址，客户端做二次请求。客户端也可以自己保存这些分solt自己判断请求哪个实际的服务。

每个主节点都会有从节点。避免节点宕机数据丢失。集群不需要哨兵，节点之间会自己判断是否有主节点宕机了选出一个从节点作为主节点。也可以用命令进行手动切换。

还可以设置**副本飘逸**，某个主节点宕机后，它的从节点成为主节点，别的主节点的从节点多，可以转移分配给这个新的主节点。

可以通过命令将一些key分片移动到新的节点或者别的节点，这不好用吧。

这样的程序需要使用客户端保存所有节点信息，随机用一个服务获取知道自己应该访问哪个实例，或者插入的时候随机插入一个实例做二次请求。都可以用客户端做一些处理。



