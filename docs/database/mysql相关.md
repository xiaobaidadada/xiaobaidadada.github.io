# 软件结构

分为服务器端，只是命令形式的允许。和客户端，客户端与服务器采用tcp方式通信，有很多版本非可视化的有mysql自带，java，python等版本的，可视化的有navicat等。

不同的表可以有不同的存储引擎。

mysql的服务器数据都在配置文件和mysql数据库中，8.0以前没有角色；

每种查询数据库都有自己的查询语言，但是肯定都会包含DDL，DML等这些sql相关的操作语法，而且每种关系数据库的这些sql操作子语言都是类似相同的。



# InnoDB

数据引擎，是负责最后处理sql语言执行查询的；这个引擎会把数据保存到磁盘；

## 数据结构

### 文件

在这个引擎下，一个表其实就是几个数据文件，有表文件也有数据文件，每个数据文件都保存着很多的数据页，这些页之间在文件角度是连续的，用这样的关系可以抽象的进行每个页相对的下一个页的偏移量，形成链表，但是实际的物理磁盘上，这些数据非常可能不是连续的，因为操作系统的文件系统有自己处理数据的方式。表文件将这些数据文件关联起来，保证了数据整体是互相连续的。

### 文件下的B+树和数据页

整个表的数据，也是采用树也叫索引的形式保存的。每个表都采用B+的形式保存数据，每一页其实就是一个B+树节点。这样做是为了减少i/o，InnoDB每次会从文件中只读取一页16KB。

页的结构除了基本的页信息外，数据区保存着多个行记录，行记录采用逻辑删除而不是物理删除，以后可以复用，还有标识是否是叶子结点页的字段。非叶子结点的页中的行记录只保存了索引键并没有数据，数据在叶子结点。这些行记录有两个链，一个正常数据链，一个垃圾链表。这两个链只存在于这个页，一个页在逻辑上是连续的，物理上应该是近连续的；

数据被删除以后首先会标识为删除，然后加入到垃圾链，如果被删除的表使用的自增主键，那么在聚集索引上，这些页上的空间可能再也无法被利用了；

由于行记录保存的有键值，所以如果查询的的select字段只有键值，走了某个索引，比如主键索引，只返回主键列，就不会进行二次回表查询子结点了（将返回结果的所有主键列key值作为集合查询）。



### 页中的行记录的格式

数据页内的行记录有不同的格式保存，每个版本的mysq都可能不同，但是都会有以下的结构；

- 有一个变长字段长度列表，用于保存变长列的当前数据大小。

- 有一个二进制的字节位保存每个null字段的状态。
- 记录有没有被删除的位，下一个记录的相对位置，记录的类型，最大最小，是否是叶子结点。
- 三个关键的隐藏字段：回滚指针（用于记录修改了什么，指向undo日志记录），事务id，主键id（不是必须的）；



## 索引

非聚集索引的叶子结点也没有数据，对于联合索引来说，每个页上都会有多个联合主键列。

通过对索引本质的理解，就是B+树，所以我们可以得出，一个查询能不能走索引，全看 能不能让 mysql 顺序遍历索引的 逻辑表达式；就是说这个查询语言能不能顺序的比较。like查询的最左，这就没法进行数值比较，只能一个一个比较，还有联合索引，没有按照最左的方式使用了查询列，这也无法按照索引的构建进行数值的比较，所有的查询只要自己想一下能不能用B+树，也就是排序树进行遍历查询就可以知道能不能走索引了。

还有一点就是，mysql一般只会走一条索引（有些还是需要多个索引，比如联合查询），因为查询本身就是查索引，数据保存的基本形式就是索引，用多个索引没有意义，那就是查多次了，mysql会根据查询语句和现有的索引做出能不能走索引，走哪个索引查，最坏没有适合的索引就会走聚集索引，所以索引失效这话不严谨的，只能说是自定义的索引失效。所以一般我们开发的时候都是先写查询语言，然后去建立相关的联合索引，尽量多的利用上这些查询字段。

像es这样的数据库，本身只有一个倒排索引，也不让建立别的什么索引，所以他不存在自定义索引失效的问题。

对于or的语句查询语句比较苛刻，InnoDB引擎需要or的每个子集都能走一个索引才会走索引。



## redo日志

这个日志只有InnoDB引擎才有，**用于数据持久化**，但是不必每次都刷新整个数据页。

他保存了每次修改数据（事务）修改了什么页，什么记录，列等信息。顺序保存到一个文件，顺序i/o，这样就可以避免每次mysql修改数据，都要修改整个页刷新到磁盘。

不同的修改，会有不同的redo日志格式。都是记录修改了什么数据。和实际数据没有关联。

也不会直接写入到磁盘，有连续的redo缓存空间。

事务提交（短的一行也算）缓存慢的时候，时间到了都会刷盘。

可以设置文件数量，以文件组的形式保存，整个文件和文件组都是环状的形式，满了就会持久化到磁盘。剩余的空间可以重复利用。

## undo日志

redo只能用于数据持久化，但是回滚它是不支持的。undo就是用于事物回滚数据的。每个业务行数据都需要关联上一些undo日志记录下回滚时候所需要的数据。

这个日志只有InnoDB才有，使用一个特殊的表空间保存，每条日志就是一行记录，这个表无法直接查询。每条记录都是当一个事务开启的时候才会有。使用FIL_PAGE_UNDO_LOG类型的页面来报错undo日志。这种页面中是由通用链表构成的。





每条记录都有主键，事务id（在某个事物范围内的，多条记录都有这个id），日志类型（大概分为增删改三种，查询不需要）。

行记录都有这三个字段：row_id（隐藏主键id，如果没有主键，也没有唯一键），trx_id（事务ID，增删改三种操作后的记录都有这个值），roll_pointer（指向undo日志）。

每一次修改动作都有一条undo日志记录，

 1. 插入日志：需要记录每个列的值和大小，还有表空间id，行记录的主键等；

 2. 删除日志：被删除的行记录只是标记了被删除，没有加入到页面的垃圾链表，事务提交之前都不会加入。roll_pointer也会指向一个删除日志。这个日志除了要记录表空间id，行记录id，还需要记录，这个记录对应的undo日志id，事务的id。加入到垃圾链别的事务就无法访问了。

 3. 更新日志：更新操作如果更新的数据，每个列的大小，都和之前的一样，就可以直接更新这行记录，如果有一个不一样，因为行记录是连续的，直接插入后面的记录就会被占用，所以需要先删除这个行记录，加入到垃圾链，去查看垃圾链中有没有合适的记录，不行申请新的，再不行就要在新的页面申请了。这个日志，会保存之前记录的列的值，依然会记录对应的行记录的更新之前的记录的undo日志。undo日志之间也会形成一个链。

      如果更新了主键，需要在原来的页面标记删除，并没直接加入到垃圾链，在事务提交前。需要生成两个日志，一个用于更新删除主键标记，一个用于在新的合适的页面插入的新纪录，同样这俩记录也会形成链，这就是**版本链**。链上每个节点都是记录的一个版本。每个节点也会记录不同事务的id？。



## 事务

### 事务实际操作

1. 开启事务，可以使用，`BEGIN`或者`START TRANSACTION`语句，START TRANSACTION语句可以加上，`READ ONLY`,`READ WRITE`,`START TRANSACTION`让当前事务只能读，或者能读能写，只能读当事务事务开启时刻的数据，重读读。隐式开启，如果autocommit变量是开启的，没有使用事务语句的所有sql语句，都是会默认开启一个事务。
2. 提交，使用`COMMIT`；如果autocommit是开启的，所有没有使用事务的语句，都会自动直接提交。如果修改了数据库表等信息，也会自动提交。不管autocommit是什么值；
3. 中止进行回滚，`ROLLBACK`，发生错误的时候会自己回滚。
4. 设置回滚点，使用`SAVEPOINT`；

### ReadView

查询访问一个记录的时候，记录和undo日志形成了一个版本链，每个事务可能会生成一个读视图，用于查询当前事务要读取的版本链上的节点，是不是已经提交的事务的数据，通过利用当前系统存在的事务id list，比较事务id大小，只有已经提交的事务才能被读（依据当前生成的事务id list做判断）。事务内没有更新操作不会生成事务id，事务id为0；

### 隔离性：

脏读，脏写：一个事务读的数据，改的数据，都是另一个事务没有提交之前的数据，可能回滚后就没了。

不可重复读：一个事务只能读取已经提交修改过的数据，且每次读取的都是最新的值；读到的数据发生了变化。

幻读：一个事务多次查询，可以查询到别的事务查询的最新值。读到了之前不存在的数据。

不同的事务之间不能完全的隔离，不然会很影响性能。如果能解决性能，完全隔离当然是最好的。**隔离级别都是针对读设置的，写是完全不允许的，完全隔离**。



MVCC指的是多版本并发控制，事务的实现利用指导性技术。

事务的隔离级别有个标准，所有的数据都有不同程度的支持（未提交读，已提交读，可重复读，可串行化）；mysql的默认隔离级别是可重复读。可以设置全局的，也可以设置会话级别，一个事务级别的隔离级别。脏写在任何级别都不会发生。

1. 未提交读的实现是依靠读取版本链的最新值。用不到ReadView；

2. SERIALIZABLE级别的隔离级别使用锁。这个序列化指的是查询顺序的序列化。

3. 已提交读，每次读的时候都会生成一个ReadView；但是在生成ReadView的读的期间内，如果别的事务有提交了，还是读不到。

4. 可重复读，在一个事务内，只有一个ReadView，这样它的当前活跃事务id list就不会变，只能读取当前状态下的记录的版本。不能读取最新的值。

   mysql在这个级别其实就解决了幻读，可能产生幻读的原因是一个长事务，的第一个语句是查询，此时还没生成事务id，因为只有更新语句才会生成事务id，所以事务id变了就可能发生幻读了。

## 锁

这些锁是概念上的，并不指某个函数或者工具。

在任何一个级别，更新了记录，都会对这个记录加锁，用事务来标识，此时别的事务写的话只能等待，读不影响（看哪种隔离级别）。

X锁是写锁，拥有写锁的事物，不允许别的事物写，也不允许读。S锁是读锁，拥有读锁的事物，只允许别的事物读，不允许别的事物写。

对于任何更新语句来说，这行记录在事务范围内都会加上X锁。



对记录进行加锁，需要在查询语句（必须），后加`LOCK IN SHARE MODE`后者`for update`加s或者x锁，被查出的语句，在这个事务范围内都会加锁。



不同引擎对锁的支持也不同；除了行锁还有表锁，这里不继续说了，用的不多。



# binlog日志

这个是所有引擎都可以使用的日志，默认是关闭的，是二进制的，保存着每一条修改语句，用于人工手动恢复数据。他也是有缓存的，这些都可以用配置文件设置。



# 连接查询是如何实现的

内连接和外链接本质上其实一样；都是对B+树的遍历；

```sql
select * from a,b on a=1 where b =1
```

对于这样的连接查询语言而言，不管是什么连接查询，都会先把where和on内的查询条件分为两类，一类是单独对某个a，b表的查询，另一个是两个表进行关联查询。然后会首先对左边的表，利用仅对左边表的查询条件进行查询；查询得到的结果作为缓存，然后用只针对于右边的表的查询条件进行查询（不管有没有使用left jon这样的语句都是这样的顺序，这些语句是为了语意，但不是必要的）。

最后利用两个表的关联查询条件，利用已经查询来的左边的表的临时记录，作为条件对右边的表进行查询。

在on内的关联查询语言，会根据left jon这样内连接查询语义选择把没有匹配上的，单独查询来的做或者右边的表保留，另一边字段设置为null；这就是内连接和外链接的区别；







# 额外知识

- mysql的所有引擎在执行更新的时候，其实对每个列都是从前往后一个一个更新的，所以可以在前一个列更新以后，使用if then以后作为条件将它作为临时变量；

- explain语句可以返回一个特定的列，展示查询语句可能的执行情况，索引执行情况。
- 5.6以后版本的mysql使用optimizer_trace可以查看查询语言可能有什么执行方案，最终选择了哪个。
- Buffer Pool是InnoDB引擎申请的缓存空间，可以使用SHOW ENGINE INNODB STATUS语言查看这个空间的状态。
- 某个联合唯一索引，某个列的值为null会使唯一主键失效；



# 查询优化

1. 让查询优化的目的是让查询走索引，避免索引失效的情况，索引失效的情况很多，联合索引没达到最左匹配，使用了or(每个条件都要走同一个索引才行)，使用了聚集函数，like使用了最左边加了%等，**只要查询无法按索引的递增值进行遍历，就会失效**；
2. 编辑mysql的配置文件启动slow_query_log等功能，可以记录慢查询的语句定位语句。
3. 然后通过explain观察为什么慢，走了什么索引。
4. 不同的查询方式，产生不走的索引的情况都是不同的。需要具体分析。



# MySQL Replication(拷贝)

这是mysql的主从复制功能，和redis的主从复制一样，用于复制拷贝主数据库文件，备份数据。从数据库请求主数据库的binglog文件在自己上重做一遍。可以实现读写分离的效果，主和从服务器依然可以读和写，当然也可以设置只允许读或者写。

# Mysql InnoDB Cluster

集群模式，其实还是进行主从复制，没有水平数据分片的功能。

# 集群

关系数据无法很好的实现集群，mysql提供的集群都是主从复制模式的，保证数据稳定性，但是数据量巨大的时候，无法实现将一个表分别保存到不同的主机上。只能使用分表的方式，现有的分布式关系型数据库国内有影响的有中兴的GoldenDB，底层依然是mysql，采用分表实现。

人工的分库分表，利用三方插件，做id的hash计算保存到不同的库和表依然是主流。分布式递增主键可以使用，uuid，雪花算法等来生成。其目的是虽然插入的是不同的表，但是插入的时间有先后顺序，后面的记录无论在哪个库哪个表都要比之前的大。

对于非关系数据库的redis（内存），mongo，es等很容易实现分片的扩展集群。

